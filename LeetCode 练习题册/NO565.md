# 565. 数组嵌套 c medium

### 知识点

数组

### 题目

索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到并返回最大的集合S，S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

#### 示例 

输入: A = [5,4,0,3,1,6,2]  
输出: 4  
解释:  
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.  

其中一种最长的 S[K]:  
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

#### 注意:

    N是[1, 20,000]之间的整数。
    A中不含有重复的元素。
    A中的元素大小在[0, N-1]之间。

#### 总结
关键在于“包含0到N - 1的所有整数” 说明没有重复元素，所以一定是在S第一个元素开始重复  
nums[i]的值作为索引,查找第nums[i]的数,不断嵌套.  
通过观察,能够发现所有的嵌套过程都会形成一个闭环,例题中A[0]会一直寻找到A[2],而A[2]的值为0,指向了A[0],任取一个数都是如此.  
每遍历一个闭环,将其所有元素的值置位-1,防止重复遍历.  
通过判断闭环长度,并取其中的最大值,即可获得结果.  

#### 代码
```
#define max(a,b) ((a)>(b)?(a):(b))
int arrayNesting(int* nums, int numsSize) {
    int res =0;
    int count = 1;
    int num = 0, temp;
    for (int i =0;i<numsSize;i++){
        if (nums[i] != -1){
            num = nums[i];
            while(num != i){
                temp = num;
                num = nums[temp];
                nums[temp] = -1;
                count ++;
            }
        }
        res = max(res,count);
        count = 1;
    }
    return res;
}
```